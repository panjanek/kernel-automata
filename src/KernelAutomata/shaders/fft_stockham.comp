#version 450

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) readonly  uniform image2D src;
layout(rgba32f, binding = 1) writeonly uniform image2D dst;

uniform int  uStage;        // stage index: 0 .. log2(N)-1
uniform int  uSize;         // FFT length (N)
uniform int  uInverse;      // +1 FFT, -1 IFFT
uniform bool uHorizontal;   // true=row FFT, false=column FFT

const float PI = 3.141592653589793;

vec2 cmul(vec2 a, vec2 b)
{
    return vec2(
        a.x * b.x - a.y * b.y,
        a.x * b.y + a.y * b.x
    );
}

void main()
{
    int k = int(gl_GlobalInvocationID.x); // output index
    int j = int(gl_GlobalInvocationID.z); // row or column index

    if (k >= uSize || j >= uSize)
        return;

    int m  = 1 << (uStage + 1);
    int mh = m >> 1;

    int r = k % mh;
    int g = k / mh;

    int i0 = g * m + r;
    int i1 = i0 + mh;

    ivec2 p0, p1, pout;

    if (uHorizontal)
    {
        p0   = ivec2(i0, j);
        p1   = ivec2(i1, j);
        pout = ivec2(k,  j);
    }
    else
    {
        p0   = ivec2(j, i0);
        p1   = ivec2(j, i1);
        pout = ivec2(j, k);
    }

    vec2 a = imageLoad(src, p0).rg;
    vec2 b = imageLoad(src, p1).rg;

    float angle = float(uInverse) * -2.0 * PI * float(r) / float(m);
    vec2  w = vec2(cos(angle), sin(angle));

    vec2 t = cmul(b, w);

    vec2 outv = (g & 1) == 0 ? (a + t) : (a - t);

    imageStore(dst, pout, vec4(outv, 0.0, 0.0));
}
