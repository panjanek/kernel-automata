#version 450

layout (local_size_x = 16, local_size_y = 16) in;

layout (rgba32f, binding = 0) readonly  uniform image2D fieldIn;
layout (rgba32f, binding = 1) readonly  uniform image2D conv1;
layout (rgba32f, binding = 2) readonly  uniform image2D conv2;
layout (rgba32f, binding = 3) readonly  uniform image2D conv3;
layout (rgba32f, binding = 4) writeonly uniform image2D fieldOut;

uniform float uMu;
uniform float uSigma;
uniform float uMu2;
uniform float uSigma2;
uniform float uSpike2Weight;
uniform float uDt;
uniform int   uSize;
uniform float uWeight1;
uniform float uWeight2;
uniform float uWeight3;
uniform float uDecay;

float gaussianGrowth(float u, float mu, float sigma)
{
    float x = (u - mu) / sigma;
    return 2.0 * exp(-x * x) - 1.0;
}

void main()
{
    ivec2 p = ivec2(gl_GlobalInvocationID.xy);
    if (p.x >= uSize || p.y >= uSize)
        return;

    float current = imageLoad(fieldIn, p).r;
    float size2 = uSize * uSize;

    float c1 = imageLoad(conv1, p).r;
    c1 /= size2;
    float growth = c1 * uWeight1;
    if (uWeight2 != 0)
    {
        float c2 = imageLoad(conv2, p).r;
        c2 /= size2;
        growth += c2 * uWeight2;
    }

    if (uWeight3 != 0)
    {
        float c3 = imageLoad(conv3, p).r;
        c3 /= size2;
        growth += c3 * uWeight3;
    }

    float g = gaussianGrowth(growth, uMu, uSigma);
    if (uMu2 > 0.0001 && uSigma2 > 0.0001 && uSpike2Weight > 0.0001)
    {
        float g2 = gaussianGrowth(growth, uMu2, uSigma2);
        g = (g + g2 * uSpike2Weight) / (1 + uSpike2Weight);
    }

    float res = current + uDt * (g - current * uDecay);

    float next = clamp(res, 0.0, 1.0);
    imageStore(fieldOut, p, vec4(next, 0.0, 0.0, 0.0));
}
